## 1. 기본 

1. 자바 언어의 특징은?
	1. 운영체제에 독립적이다
	2. 객체지향언어이다
	3. 비교적 배우기 쉽다
	4. 자동 메모리 관리
	5. 네트워크와 분산처리를 지원한다
	6. 멀티쓰레드를 지원한다
	7. 동적로딩을 지원한다


## 2. 변수

1. 변수의 정의는 무엇인가? 값을 저장할 수 있는 메모리상의 공간
2. 변수값 교환은 무엇인가?
3. 식별자는 무엇인가?
4. 변수의 타입이란 무엇인가?
5. 자료형의 정의는?
	* 기본형에 대해서 서술하시오
		* 상수:
		* 리터럴:
	* 참조형의 정의는? 
	**객체의 주소를 저장 클래스 이름 변수이름; 
	변수 타입이 기본형이 아닌것은 모두 참조 변수이다
	참조변수의 타입은 클래스 이름이다.**
6. 오버플로우는 무슨 뜻인가?
7. 형변환이란 무엇인가?
8. 자동형변환 규칙이란 무엇인가?
9. * boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
	* 기본형과 참조형은 서로 형변환할 수 없다.
	* 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
	값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다. 

## 3. 연산자

1. 연산자란 무엇인가? 연산을 수행하는 기호
2. 피연산자란 무엇인가? 연산자의 작업 대상(변수,상수,리터럴,수식)
3. 연산자 종류에 대해서 서술하시오(5가지)
4. 연산자 우선순위에 대해서 서술하시오(3가지)
	* 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
	* 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
	* 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
5. 연산자의 종류
	* 단항 연산자 -> ++  --  +  -  ~  !  (type)
	* 대입 연산자 -> =  +=  -=  *=  /=  %=
								<<=  >>=  &=  ^=  |= 
6. 산술변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
	* 두 피연산자의 타입을 같게 일치시킨다 (보다 큰 타입으로 일치)
	* 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
7. 나머지 연산자 %는 나누는값이 절대값을 가진다 10%-8 -> 2 / -10%-8 -> -2


## 4. 조건문과 반복문

1. 자바에서 조건식의 결과는 반드시 true 또는 false이어야 한다
2. switch문의 제약 조건
	* switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
	* case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
3. Math.random() 메서드
	* 기본형 0.0 <= Math.random() <1.0
	* 각 변에 3을 곱한다.
	* 각 변을 int형으로 변환한다
	* 각 변에 1을 더한다 -> 1<= (int)(Math.random() * 3) + 1 <4
		이제는 1과 3사이의 정수 중 하나를 얻을 수 있다. 1은 포함되고 4는 포함되지 않는다.
4. 반복문 - for,while,do-while
	* for문이나 while문에 속한 문장은 조건에 따라 한 번도 수행되지 않을 수 있지만 
	do-while문에 속한 문장은 무조건 최소한 한 번은 수행될 것이 보장된다.
5. 향상된 for문
```
	for( 타입 변수명 : 배열 또는 컬렉션) {
		// 반복할 문장
	}
	
	위의 문장에서 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 
	배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다. 
	그리고 반복문의 괄호 {} 내에서는 이 변수를 사용해서 코드를 작성한다.
	하지만 향상된 for문은 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 
	읽어오는 용도로만 사용할 수 있다는 제약이 있다
```
6. while문
	* 조건식이 참(true)이면 블럭{}안으로 들어가고, 거짓(false)이면 while문을 벗어난다.
	* 블럭{}의 문장을 수행하고 다시 조건식으로 돌아간다.
	* 한 가지 주의할 점은 for문과 달리 while문의 조건식은 생략할 수 없다는 것이다.
7. break문
	* break문은 자신이 포함된 가장 가까운 반복문을 벗어난다. 
	주로 if문의 조건또는 무한 반복문에 사용함
8. continue문
	* continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 
	도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.
	for문의 경우 증감식으로 이동하며, while문과 do-while문의 경우 조건식으로 이동한다.
	continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이
	 break문과 다르다. 주로 if문과 함께 사용되어 특정 조건을 만족하는 경우에 continue문 
	 이후의 문장들을 수행하지 않고 다음 반복으로 넘어가서 계속 진행하도록 한다.


## 5. 배열(array)

1. 배열(array)이란 무엇인가?->'같은 타입'의 여러 변수를 하나의 묶음으로 다루는 것
```
	 타입 [] 변수이름; //배열을 선언(배열을 다루기 위한 참조변수 선언)
	 변수이름 = new 타입[길이]; // 배열을 생성(실제 저장공간을 생성)
```
2. 배열의 요소와 인덱스는 무엇인가? 요소->생성된 배열의 각 저장공간 / 	
인덱스-> 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용
3. 배열의 길이는 int 범위의 양의 정수(0도 포함)이어야 한다.
4. 배열은 참조변수를 통해서만 접근할 수 있기 때문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다. 이렇게 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해서 자동적으로 메모리에서 제거된다.
5. 배열의 복사
	* 배열의 복사는 for문보다 System.arraycopy()를 사용하는 것이 효율적이다.
6. 참조형 변수란? -> 모든 참조형 변수에는 객체가 메모리에 저장된 주소인 4 byte의 정수값(0x0~0xfffffff) 또는 null이 저장된다.
7. String클래스는 char배열에 기능(메서드)을 추가한 것이다.
	* char배열과 String클래스의 한 가지 중요한 차이가 있는데, String객체(문자열)는 읽을수만 있을 뿐 내용을 변경할 수 없다는 것이다.
8. String 클래스의 주요메서드는? charAt,length,substring,equals,toCharArray

## 6. 객체지향 프로그래밍 1

1. 객체지향언어의 특징은?
	* 1.코드의 재사용성이 높다 
	* 2.코드의 관리가 용이하다 (유지보수)
	* 3.신뢰성이 높은 프로그래밍을 가능하게 한다. ( 중복 제거)
2. 클래스란 '객체를 정의해 놓은것' 또는 '객체의 설계도 또는 틀' 
3. 객체의 사전적 정의는 '실제로 존재하는 것'이다 
4. 인스턴스화란? 클래스로부터 객체를 만드는 과정
5. 인스턴스란? 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
6. 객체의 구성요소는? 속성과 기능 그리고 그 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(member)라고 한다.
7. 속성 -> 멤버변수
8. 기능 -> 메서드	
9. 클래스 변수 생성시기-> 클래스가 메모리에 올라갔을 때
   인스턴스 변수 생성시기 -> 인스턴스가 생성되었을 때
	 지역변수 생성 시기-> 변수 선언문이 수행되었을 때
	 ```
	 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은
	 인스턴스의 타입과 일치해야 한다.
	 ```
10. 메서드란 특정 작업을 수행하는 일련의 문장들을 하나로 묶은것
	* 같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성(멤버변수)은 서로 다른 값을
	유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.
	* 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 '가비지 컬렉터'에 의해서 자동적으로 메머리에서 제거된다.
	* 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않다.
11. JVM 그려보기 
12. 객체 배열을 생성할 땐 참조 배열 생성 후 객체를 생성하는것을 잊으면 안된다
	* **Tv[] tvArr = { new Tv(), new Tv(), new Tv() };** <-- tv참조변수 배열 선언과 객체 생성
13. 기본형 매개변수와 참조형 매개변수 
	* 기본형 매개변수 -> 변수의 값을 읽기만 할 수 있음(read only)
	* 참조형 매개변수 -> 변수의 값을 읽고 변경 할 수 있다(read&right)
14. 변수와 메서드
	* 인스턴스 변수 - > 독립적인 공간을 가지므로 서로 다른 값을 가질 수 있다
	* 클래스 변수 -> 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 한다
	클래스 변수는 인스턴스 변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용 
	할 수 있다.
15. 기본형 매개변수와 참조형 매개변수
	* **기본형 매개변수** -> 변수의 값을 읽기만 할 수 있다.(read only)
	* **참조형 매개변수** -> 변수의 값을 읽고 변경할 수 있다.(read & write)
	* **참조형 반환타입 268~269쪽**
	* 반환 타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.
16. 클래스 멤버와 인스턴스 멤버간의 참조와 호출
	* 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는
	인스턴스를 생성해야 한다.
	그 이유는 **인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 
	클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.** 
17. 오버로딩이란? 한 클래스 내에 같은 이름의 메서드를 여러개 정의 하는것 
 메서드 이름이 같아야 하고 매개변수의 개수 또는 타입이 달라야 한다
18. 생성자란(Constructor)? 인스턴스가 생성될 때 호출되는 '인스턴스  초기화 메서드'이다.
19. 생성자의 조건 
	* 생성자의 이름은 클래스의 이름과 같아야 한다 
	* 생성자는 리턴 값이 없다.
	* **연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.**
		+ Card c = new Card();
		1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
		2. 생성자 Card()가 호출되어 수행된다.
		3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
	* 지금까지 인스턴스를 생성하기위해 사용해왔던 '클래스이름()'이 바로 생성자였던 것이다.
20. 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다
21. 생성자에서 다른 생성자 호출하기 - this(),this  
	* 생성자의 이름으로 클래스 이름 대신 this를 사용한다
	* 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
22. 'this'는 참조변수로 인스턴스 자신을 가리킨다. 참조변수를 통해 인스턴스의 멤버에 접근할
수 있는 것처럼, 'this'로 인스턴스변수에 접근할 수 있는 것이다. 하지만 'this'를 사용할 수 있는 것은 인스턴스 멤버 뿐이다. static 메서드에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, 'this' 역시 사용할 수 없다
	* this -> 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
	* this(), this(매개변수) -> 생성자, 같은 클래스의 다른 생성자를 호출 할 때 사용한다.
	- this와 this()는 비슷하게 생겼지만 완전히 다른 것이다. this는 '참조 변수'이고 this()는 '생성자'이다.
23. 인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야한다.
	* 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
	* 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?
24. **멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.**
25. 멤버 변수의 초기화 방법
	* 명시적 초기화(explicit initialization) -> 변수를 선언과 동시에 초기화
	* 생성자(constructor)
	* 초기화 블럭(initialization block)
		- 인스턴스 초기화 블럭: 인스턴스 변수를 초기화 하는데 사용
		- 클래스 초기화 블럭:  클래스 변수를 초기화 하는데 사용
26. 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행된다. 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다. 그리고 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다
27. 인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용한다.

## 7. 객체지향 프로그래밍 2

1. 상속이란? 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
	* 조상클래스 -> 부모,상위,기반 클래스
	* 자손 클래스 ->자식,하위,파생된 클래스
    * **생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다**
    * **자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다**
    * **자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.**
2. 상속이외에도 클래스를 재사용 하는 또 다른 방법은 '포함'관계 이다. 클래스 간의 포함 관계를 맺어 주는 것은 한 클래스의 멤버 변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.
	* is a(~은 ~이다) -> 상속 관계
	* has a(~은 ~을 가지고 있다) -> 포함관계
3. 오버라이딩(overriding)이란? 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩 이라고 한다. 자손 클래스 자신에 맞게 변경하는 경우 
4. 오버라이딩의 조건
	* 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
		- 이름이 같아야 한다
		- 매개변수가 같아야 한다
		- 반환타입이 같아야 한다
	* 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
		- 만일 조상 클래스에 정의된 메서드의 접근자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 대부분의 경우 같은 범위의 접근 제어자를 사용한다.
	* 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
	* 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
5. 오버로딩 vs 오버라이딩
	* 오버로딩 -> 기존에 없는 새로운 메서드를 정의하는 것(new)
	* 오버라이딩 -> 상속받은 메서드의 내용을 변경하는 것(change, modify)
6. super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 
	사용되는 참조 변수 이다. 
멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다. 
모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다.
static메서드는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.
7. super() - 조상 클래스의 생성자
	* this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다. 
자손 클래스의 인스턴스가 조상 클래스의 멤버를 사용 할 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다. 
생성자의 첫 줄에서 조상클래스의 생성자를 호출해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.
	* Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super(), 를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
	* 생성자가 정의되어 있는 클래스에는 컴파일러가 기본 생성자를 자동적으로 추가하지 않는다.
	* **조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화 되도록 해야 하는것이다.**
8. 클래스 파일들을 압축한것이 jar 파일(*.jar)이며, jar파일은 'jar.exe'외에도 알집이나 winzip으로 압축을 풀 수 있다.
9. 제어자란? 제어자는 클래스,변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
	* 접근제어자 -> public, protected, default, private
		- 접근 제어자가 사용될 수 있는 곳 -> 클래스, 멤버변수, 메서드, 생성자
			+ private 같은 클래스 내에서만 접근이 가능하다
			+ default 같은 패키지 내에서만 접근이 가능하다
			+ protected 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다
			+ public 접근 제한이 없다
		- 접근 제어자를 사용하는 이유
			+ 외부로부터 데이터를 보호하기 위해서
			+ 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
		- get으로 시작하는 메서드는 단순히 멤버변수의 값을 반환하는 일을 하고,
		- set으로 시작하는 메서드는 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성되어 있다.
		- 보통 멤버변수의 값을 읽는 메서드의 이름을 'get멤버변수이름'으로 하고, 멤버변수의 값을 변경하는 메서드의 이름을 'set멤버변수이름'으로 한다
   ---
	* 그 외           -> static, final, abstract, native, transient, synchronized, volatile, strictfp
		- static - 클래스의,공통적인
			+ 클래스 변수는 인스턴스에 관계없이 같은 값을 갖는다. 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문이다.
			+ static이 사용될 수 있는곳 -> 멤버변수, 메서드, 초기화 블럭
		- final - 마지막의,변경될 수 없는
			+ final은 거의 모든 대상에 사용 될 수 있고 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
			+ final이 사용될 수 있는곳 -> 클래스,메서드,멤버변수,지역변수
			+ final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.
		- abstract - 추상의,미완성의
			+ abstract는 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다. 그리고 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.
			+ 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'
			이므로 인스턴스를 생성할 수 없다.
			+ abstract가 사용될 수 있는 곳 -> 클래스, 메서드
10. 제어자의 조합(사용가능한 제어자)
	* 클래스 -> public, (default), final, abstract
	* 메서드 -> 모든 접근 제어자, final, abstract, static
	* 멤버변수 -> 모든 접근 제어자, final, static
	* 지역변수 -> final
11. 제어자를 조합해서 사용할 때 주의사항
	* 메서드에 static과 abstract를 함께 사용할 수 없다
		- static메서드는 몸통이 있는 메서드에서만 사용할 수 있기 때문이다.
	* 클래스에 abstract와 final을 동시에 사용할 수 없다
		- 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다
	* abstract메서드의 접근 제어자가 private일 수 없다
		- abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다
	* 메서드에 private과 final을 같이 사용할 필요는 없다
		- 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다	
12. 다형성(polymorphism)이란?	-> '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 
이를 좀 더 구체적으로 말하자면,  **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다**는 것이다. 
같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.
**참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다**
참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정한다는 사실을 이해하는것은 매우 중요하다.
	+ 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다
	+ 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다
13. 참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스사이에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다.
	* 자손타입 -> 조상타입(Up-casting) : 형변환 생략가능
	* 자손타입 <- 조상타입(Down-casting) : 형변환 생략불가
14. **형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 
단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.**
	* 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나,
	 **참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
	그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.**
15. instanceof연산자 -> 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인한다. 주로 조건문에 사용되며, instanceof 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다. 그리고 연산의 결과로 boolean 값인 true와 false 중의 하나를 반환한다.
instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 말한다.
	* 값이 null인 참조변수에 대해 instanceof연산을 수행하면 false를 결과로 얻는다. 
	* 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
16. 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다. 메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩 된 메서드)가 호출되지만, **멤버변수의 경우 참조변수의 타입에 따라 달라진다.** 결론부터 말하자면, 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.
17. 추상클래스(abstract  class)란? 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도	에 비유할 수 있다. 클래스가 미완성이라는 것은 멤버의 개수에 관게된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다. 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. **추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.**
추상클래스는 키워드 'abstract'를 붙이기만 하면 된다. 이렇게 함으로써 이 클래스를 사용할 때, 클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있을 것이다.	
추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반클래스와 전혀 다르지 않다. 추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다. 

> 추상메서드를 포함하고 있지 않은 클래스에도 키워드 'abstract'를 붙여서 
추상클래스로 지정할 수도 있다. 
추상메서드가 없는 완성된 클래스라 할지라도 추상클래스로 지정되면 클래스의 
인스턴스를 생성할 수 없다.

18. 추상메서드(abstract method)란? 
메서드는 선언부와 구현부(몸통)로 구성되어 있다고 했다. 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다. 즉, 설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.
추상메서드 역시 'abstract'를 앞에 붙여 주고, 추상메서드는 구현부가 없으므로 괄호{}대신 문장의 끝을 알리는 ';'을 적어준다.
> 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.
abstract 리턴타입 메서드이름();
19. 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.
20. **추상**:낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용
상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것이라고 할 수 있다.
추상화를 구체화와 반대되는 의미로 이해하면 보다 쉽게 이해할 수 있을 것이다.
	* **추상화** -> 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
	* **구체화** -> 상속을 통해 클래스를 구현, 확장하는 작업
21. 인터페이스(interface)
인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.
추상클래스를 부분적으로 완성된 '미완성 설계도'라고 한다면, 인터페이스는 구현된것은 아무 것도 없고 밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.
인터페이스도 추상클래스처럼 완성되지 않은 불완전한 것이기 때문에 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.
22. 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.
> 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.
23. **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.**이 문장은 외울 때 까지 반복해야 한다.
24. **인터페이스의 장점**
	* 개발 시간을 단축시킬 수 있다.
	* 표준화가 가능하다.
	* 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
	* 독립적인 프로그래밍이 가능하다.
25. 인터페이스를 이해하기 위해서는 다음의 두 가지 사항을 반드시 염두에 두고 있어야 한다
	* 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
	* 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다. (내용은 몰라도 된다.)



